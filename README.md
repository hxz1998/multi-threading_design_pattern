# 多线程设计模式学习

## 0. 关于UML

1. 类图
    1. 继承：实线 + 空心箭头 `-▷`
        1. 静态字段或者方法使用下划线表示
        2. 抽象类或者方法使用斜体
    2. 接口：虚线 + 空心箭头 `··▷`
    3. 聚合：菱形 + 实线 + 箭头 `◇->`
    4. 关联： 实线 + 箭头 `->`

2. 可见性
    1. `-` 表示私有 `private` 字段或者方法
    2. `#` 表示保护 `protected` 字段或者方法
    3. `+` 表示公有 `public` 字段或者方法
    
## 序章 1 Java线程

**Tips:** 
> `java.nio` 中包含兼具性能和可扩展性的 `I/O` 处理。即使不用线程，也可以很好地处理 `I/O` 请求。

1. 顺序、并行和并发：**顺序（Sequential）** 执行就是多个操作 **依次处理** ，比如十个操作交给一个人来做；
**并行（Parallel）** 表示多个操作 **同时处理** ，比如十个操作交给两个人来做；
**并发（Concurrent）** 表示将一个操作 **分割成多个部分，而且允许无序处理**。 

2. `synchronized` 方法：方法在声明时在前面加上 `synchronized` ，那么这个方法在同一个时间上，只能够被一个线程所放问。也被称为同步方法。
例如：

    ```java
    public synchronized void write(String message) {}
    ```
    这时，每一个实例都有一个锁，而不是该类的所有实例共用一把锁。可以使用 `assert Thread.holdsLock(obj);` 来判断当前线程是否已获取某一个对象 `obj` 的锁。
    
    当然，也可以使用 `synchronized` 来修饰代码块，例如：
    
    ```java
    synchronized (this) { 
        // 代码块 
    }
    ```
    
    此外，静态方法的锁和实例方法锁是不同的。一个是 `synchronized(this)` 一个是 `synchronized(Something.class)` 。

3. `wait` 、 `notify` 、 `notifyAll` 三个方法，`wait` 方法将当前线程 **（要求获得了对象锁）** 放到了当前实例的 **等待队列** 中，并且释放 **对象锁** 。
同样的， `notify` 和 `notifyAll` 也需要持有对象锁才可以（这是规则）。
**Tips:**
> 在一般情况下，要使用 `notifyAll` ，因为该方法更加稳妥。
    
## 序章 2 多线程程序的评价标准

|指标|含义|目标|
|---|---|---|
|**安全性**|不损坏对象|必要条件|
|**生存性**|必要的处理能够被执行|必要条件|
|性能|能被大批量、快速地执行|提高质量|
|可复用性|类可被重复使用|提高质量|